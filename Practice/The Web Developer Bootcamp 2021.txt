aici vad schimbarile aduse cursului:
https://www.notion.so/Web-Developer-Bootcamp-ChangeLog-45e3eab6be724c5f9a4b83c01044e126

12. The Internet in 5 minutes:
	Internet = network of networks

13. Intro to the Web:
	URL = Uniform Resource Locators
	Web = information system taht allows us to share resources over the internet; these resources
are identified by the URL

HTTP = HyperText Transfer Protocol -> asa functioneaza WWW-ul World Wide Web
	= reguli standardizateI(protocol)despre cum ar trebui sa functioneze comunicarea
- exista multe alte protocoale

	Cand de exemplu dam un refresh pe reddit --> generam un request; un request catre
URL-ul respectiv, more specifically. semnal catre unul din serverele Reddit, iar apoi
semnal back la noi

Web Server(ca la retele): = masini (de calcul) conectate la internet a caror whole purpose
este de a satisface requests coming in via the Web

La baza, Web-ul este sistemul de a impartasi resurse over the Internet si e in intregime con-
struit pe aceasta chestie (protocol) nuimt HTTP

client = device-ul cu request-ul / "client side"


14. The Request / Response Cycle
-----------------------------------
	Ce se intampla cand fac un request iar acel request ajunge la server?
Ei bine, server-ul nu raspune cu pagina web!! Serverul raspunde cu instructiuni pe care
browserul clientului le intelege; job-ul browserului este sa "render" content for the client
adica sa interpreteze acele instructiuni. Deci serverul returneaza un set de instructiuni!!
ca la Ikea; instructiunile nu sunt in sine canapeaua.

Cum arata aceste instructiuni?
	In Chrome: click-dreapta si "view page source " <--- astea vin de la server iar 
browser-ul le interpreteaza si le transforma in ceva ce omul intelege !!
	!!! TOT CODUL ASTA CONSTA DIN HTML, CSS SI JAVASCRIPT(JS) !!!


15. Front-End / Back-End


16. What do HTML/CSS/JS do?
HTML - the what?
CSS - the style adjectives ( infrumuseteaza )
JS - the actions

20. Introduction to HTML
-----------------------
html -- not full blown programming language
	-- marking up document adica asa cum face profa cand iti corecteaza lucrarea..
"marcheaza" lucrarea


mark-up = the process or result of correcting text in preparation for printing

creem elemente in html folosind tag uri...
 !! most - but not all of - the elements consist of an oopening and cosing tag:
<p> paragraf </p>

21. Our very first HTML Document
--------------------------------


22. Mozilla Developer Network
------------------------------
references ... toate tag-urile acolo

23. Paragraph elements
----------------------


24. Heading elements:
h1 - main heading
h1 -> h6 ( is mai mici treptat ca font, dar nu de asta le folosim )
ONE H1 at most on a page
!! niciodata nu am hn fara sa am h(n-1)


25. Chrome Inspector


26. HTML Boilerplate
-----------------------
chestii standardizate care trebuie sa intre in orice document html

html element -> the root element
title element -> titul tabului


27. VSCode Tip
-------------
ctrl + shift + p --> The VSCode Palette (cauti format document sau ce ai nevoie)
       shift + alt + f --> format document
ctrl + , --> settings -- am aici save on format !!
shift + alt + down arrow --> duplica linia


28. List elements
-----------------
ol -> ordered list (numbered points)
ul -> unordered list (bullet points)
<li> --> list element -- apare doar intre <ol> ... </ol> sau <ul> ... </ul>

29. Anchor tag
--------------
prin elementul asta legam link-uri catre alte pagini sau chiar catre alta sectiune a paginii
curente

ATRIBUTE !! = little pieces of info that we pass to a tag; href = hypertext reference probabil

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
34. Inline vs Block Comments
block: paragraph ,h1, h2
inline: 

<div> vine de la division / divider
--> e un container generic to hold/group things together
--> e un element de tip "block"
--> deci e o metoda de a grupa continut impreuna pentru a-i trata similar unitatile ce 
alcatuiesc intregul

<span>
--> idem
--> e un element de tip "inline"
--> idem
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


35. <hr> <br> <sup> <sub>
<hr> horizontal rule
--> nu are ending tag
--> e o linie orizontala care are la mijloc un semn ceva;
--> "thematic break" between parapgraph level elements

<br> line break (endline)
--> poezii

<sup>, <sub> superscript subscript

36. HTML Entities (aka "entity codes")
--------------------------------------
sunt diferite caractere: copyright symbol, diamond, cruce etc
--> incep cu un ampersand si se termina cu punct-virgula
--> folosite pt a afisa diverse caractere care ar fi invalide otherwise
--> browserul le interpreteaza si "renders" the correct character!!


37. Semantic Markups
---------------------
header, footer, nav, section, article, main...
--> toate se comporta ca div doar ca ofera un anumit sens !!

Dar totusi.. dc ar conta? Evident pt ca adauga inteles !!
		2) pt ca ajuta web crawlers sa indexeze continutul si pe screen readers

DECI ASTA ADAUGA INTELES!!!

38. Playing With Semantic Elements
---------------------------------
: instead of using generic containers - such as <div> - we can use specific ones, like:
main, nav, section, header, footer

<section>
<article>
<nav>
<main>
<header>
<footer>
<aside>
<summary>
<details>
.. plus : <time> - inline
<figure> (optional sa apara in interiorul sau: <figcaption>)
<abbr>
<data>

<main> --> continutul principal specific continutului paginii; ceva ce nu se repeta pe alte 
pagini

<article> --> ceva self-contained ce ar putea fi refolosit pe alte site-uri (cum ar fi un 
weather widget)

<aside> --> ceva nenecesar

<header> --> introductroy content; poate include navigational content la fel de bine
<footer> -->


!! SEO = SEARCH ENGINE OPTIMIZATION !!

39. Screen Reader Demonstration
-------------------------------




42. Unit Goals

43. HTML Tables

44. Table Elements: TR, TD, TH
<td> table data cell deci o intrare pe un rand ( a cell )
<tr> un rand nou
<th> table heading - numele coloanei; dar si astea trebuie sa apara pe un rand, deci 
intre prima pereche: <tr> si </tr>, iar aceasta prima pereche apare la randul ei
(se explica in videoul urmator intre <thead> si </thead>)



45. Tables: Thead, Tbody, Tfoot elements
----------------------------------------


46. Colspawn & Rowspan !!
----------------------

47. The Form Element
-------------------
<form> --> grupeaza + dicteaza unde se trimite informatiile din form cand se da submit

exemplu cu search pe reddit pe la minutul 06:10
ceva http request cand dai search:
"an http request will be fired off to /search" (cand apasa search)
/search nu e un website pe care putem merge. asta e relativ pagina site-ului pe care 
ne aflam deja

! when submitting a form, an http request will be sent and we control where that request goes
to using the attribute called "action" ( al lui <form> ) si controlam ce tip de http method
folosind atributul "method"

48. ce intra intr-un form?
--------------------------
<input> !!! extrem de versatil: checkbox, color picker, date picker, password input, text input
atributul "type" e important !!
INPUT NU ARE CLOSING TAG !!!

49. "the All-important Label"
----------------------------
cand asociez un label cu un textbox/checkbox/altele... pot apasa si pe label; se va interpreta 
ca clicul pe checkbox

!! for, id !!


50. Buttons
---------
<button> text_button </button>
open+close tag

orice buton intr-un form pt care nu se specifica explicit ce ar trebui sa faca este asociat
cu actiunea form-ului!! adica "action"-ul form-ului!!

51. The name attribute(for input)
----------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
cand dam submit la un form se trimite un http request catre actiunea form-ului !!!
si apoi se trimit datele!! "q=silkie" --> asta e numele input-ului !!

--> trebuie pus la orice input folosim!!

52. Hijacking" Google & Reddit's Search
---------------------------------------
!!!!!!!!!!!!!!!!!
atributul name !!! --> asta e numele variabilei pt server

trebuie sa matchuim "actiunea" noastra (query-ul / http-get request-ul) cu sintaxa pe care serverele
reddit o asteapta
!!!!!!!!!!!!!!!!!



53. !!!!!!!!!!! Alte chestii pt <input> !!!!!!!
--------------------------------------------
daca un checkbox e unchecked, atunci nu apare in query; in schimb, daca e checked va aparea

diff intre radio si checkbox e ca e la radio am voie sa am doar o optiune aleasa!!
!! atributul 'value' in cazul UNOR(deci mai multe) radio buttons este foarte important pt ca
!! ne ajuta sa trimitem valoarea checkboxului (in loc de yes/no) !!!!!
!! in general pt input: atributului 'name' i se atribuie valoarea atributului 'value' when
we submit a form !!
<!-- PRIN atributul 'name' le grupam pe toate, adica impunem user-ului sa bifeze un singur cerculetz din astea de mai jos !! -->


<select> + <option>
selected
o optiune fara

54. Range & Text Area
--------------------

55. validations
--------------
patterns

56. form
-------


!!! holding alt and clicking in multiple specific places voi crea mai multi cursori



58. CSS
---------
cand scriem

59. What is CSS?
----------------
!! cand scriem css, scriem css-reguli / css-rules !!
pattern/template basic:

selector {
   property: value;
}

asa facem toate h1-urile purple!!
h1{
  color: purple;
}

img{
width: 100px;
height: 200px;
}


toate input-urile unde tipul e selectat la text, din 2 in 2
input[type="text"]: nth-of-type(2n){
    border:2px solid red;
}

61. Including Styles Correctly
-----------------------------
External Stylesheets - cea mai buna varianta de a lucra cu css, dar exista si variantele:
--> <style> (in head-ul documentului html)
--> style direct ca atribut in elementul!!

!! Elementul <link> !!
--> il includem in head-ul html-ului

62. Color
---------
toate variantele alea de pe mdn reprezinta o singura culoare!!

63. Color Systems
-----------------
/* 
rgb(255,0,0) - red
rgb(0,0,255) - blue
rgb(0,255,0) - green
rgb(173,20,219) - un purple
rgb(0,0,0) - black
rgb(255,255,255) - white
*/

64.Hexadecimals / Hex Colors
----------------------------

!!! properties / proprietatile sunt ceea ce stilizam la anumite elemente
(selectorul le selecteaza, iar proprietatile


66. Text Properties
-------------------

68. The Font Family Property
----------------------------
Font stack = list of fonts de folosit, in ordine

69. Universal / Element Selectors
---------------------------------
* -> tot
* {
color: black;
}


71.
!! Ca sa "stilizez" ceva specific, adica ceva cu un ID:
#logout{
	color: orange;
	height: 200px;
}

72. The Class Selector 
---------------------
#logout{		/* asta e pt elemente cu id!!*/
	color: orange;
	height: 200px;
}

.complete{		/* Asta e pt elemente din aceeasi clasa! */
	color: green;
}

73. Descendant selectors
--------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

li [space] a {			/* selecteaza toate anchor tag-urile care sunt nested(/"descendant": e acelasi lucru) al unui li(list item)
	color: teal; 
}

li, a{ 			--> e cu totul diferit cu virgula
	color: teal;
}
se pot combina in mai multe feluri!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

74. Adjacent selector / Direct descendant(child) selector
--------------------------------------------------------
(sunt numite combinators aste de genul: h1 + p --> plusul e combinator)
adjacent selector:
/* asta de jos: selecteaza doar paragrafele care sunt imediat precedate de un h1 */
h1 + p{
	color:red;
}

adjacent: +     --> "h2+button"
direct-child: >     --> "footer>a"

75. The Attribute selector
---------------------------
pt input !! (the type attribute)
input[type="text"]{
}

class si id sunt si ele atribute !!



section[class="post"]{
    background-color: purple;
}
/* astea 2 cred ca sunt echivalente*/
/* .post{
    background-color: purple;
} */

/*obs: daca aveam mai multe elemente de tipuri diferite in clasa "post"
 dar voiam doar pe acelea care sunt de tip "section" puteam face:
 section.post{
... 
}
 */ 
/* astea 2 cred ca sunt echivalente*/
/* .post{
    background-color: purple;
} */

/*obs: daca aveam mai multe elemente de tipuri diferite in clasa "post"
 dar voiam doar pe acelea care sunt de tip "section" puteam face:
 section.post{
... 
}
 */ 
/* astea deja intra in expresii regulare*/
 a[href*="google"]{     /* anchor tags care contin "google" */
     color:magenta
 }

 a[href$=".org"]{       /* anchor tags care se termina in ".org" */
     
 }

 


OBS: tot ce pe MDN e cu a little flask next to it(o


!!! ATENTIE MARE CU PSEUDO-ASTEA... CONTEAZA SA NU FIE SPATIU INTRE ":" SI PARTEA STANGA,
RESPECTIV DREAPTA A ":" !!!
76. Pseudo Classes ":"
----------------------
sunt multe

!!cu astea stilizam un element bazat pe "state"!!

un fel de modifiers; keywords pe care le adaugam la un selector ca sa specificam "the state"
of the selected elements. The state poate fi - dar nu cred ca se rezuma la:
:active
:checked
:first
:first-child
:hover
:not()
:nth-child()
:nth-of-type()

!! Toate incep cu colon(doua puncte:)

!!! ATENTIE MARE CU PSEUDO-ASTEA... CONTEAZA SA NU FIE SPATIU INTRE ":" SI PARTEA STANGA,
RESPECTIV DREAPTA A ":" !!!
77. Pseudo Elements "::"
-------------------------
nu s asa multe

cu astea stilizam (un element) parti ale unui element selectat - selectat intr-un anume fel-!!!

astea ne ajuta sa stilizam o parte specifica a elementelor selectate
::after
::before
::first-letter
::first-line
::selection


78. The Cascade
---------------
2 conflicting styles (prolly cu aceeasi precedenta) --> va castiga ultima care apare!!
!! conteaza si ordinea in care apar link-urile in head-ul html-ului!!

79. Specificity
---------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Cand avem acelasi tip de selector --> conteaza doar ordinea! adica "The Cascade"

Cand nu --> Specificity = "ce reguli sa aplice un browser cand exista un conflict?"
conflict = mai multe reguli se pot aplica unui element
!!! Cum o spune si numele "SPECIFICITY" --> cel mai specific selector castiga !!!

--tre sa le simtim astea:
p{
  color:yellow;
}

section p{
  color: teal;
}

e clar ca al doilea e mai specific

formula generala:
	ID > CLASS > ELEMENT

nav a.active{

}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


80. Chrome Dev Tools (inspect-ul)
----------------------------------

81.Inline styles(the most specific things, but almost nobody uses them)
-----------------------------------------------------------------------
The !important exception (rule)

.foo[style*="color: red"]{
  color: firebrick !important; --> asta e exceptie la modelul specificitatii si overrides orice exista deja
--> "cea mai cea mai" specifica (nici macar nu ia parte la regulile jocului specificitatii, ci castiga implicit)

}


82. CSS Inheritance
-------------------
!!!!!!!!!!!!!

83. Box Model

84. Box Model
--------------
cam totu is a box
padding e distanta de la content box la border iar -spre deosebire- 
margin e distanta de la borderul box-ului respecitv la altceva ( alt element)

padding = distanta inside of the border
margin = distanta outside of the border

width & height controleaza dimensiunea inner content-ului 

cea atentie la box-sizing nujce

85. Border & Border-Radius
--------------------------
reprez border-ul din jurul elementului (deci content-box + padding are surrounded by this)

main 3 properties:
border-width
border-color
border-style

!!
box-sizing: border-box
------------------------
/* border-box tells the browser to account for any border and padding in
 the values you specify for an element's width and height. If you set an
  element's width to 100 pixels, that 100 pixels will include any border 
  or padding you added, and the content box will shrink to absorb that 
  extra width. This typically makes it much easier to size elements. */
!!

!! In inspect: 
cu albastru -> content area
cu green -> padding
cu portocaliu -> margin
!! In inspect

86. Padding (se foloseste mostly pixels)
----------------------------------------
4 feluri de a folosi:
padding: 10px
padding: 5px 10px ( vertical orizontal )
padding: 1px 2px 2px ( top horizontal bottom )
padding: 5px 1px 0 2px ( top right bottom left -> trigonometric; orar )

88. The Display Property
------------------------

!! F IMPORTANT !!!



89. CSS Units - Relative & Absolute Units
-----------------------------------------
width: 50% -> 50% din valoarea parintelui
line-height: 50% -> jumatate din font-size-ul elementului insusi

deci unele is relative la parinte, altele relative la o proprietatea a lor insisi
!! in general, procentele sunt folosite cu proprietati, precum: widht, height

90. CSS Units: ems
-----------------
1 em inseamna font-size ul parintelui ( dar nu pt toate proprietatile )
cu alte proprietati, 1 em este egal cu font-size-ul parintelui


91. CSS Units: rems
-------------------
Rezolva problema cu recursivitatea la em-uri

!! r-ul vine de la root!! deci relativ la font-size-ul intregului document !!
<html> e root-element-ul !!!

91 --> ??05:30??

93. Opacitate & Alpha-Channel
----------------------------
rgba (a,b,c,opacitate) unde 0 <= opacitate <= 1

94. The Position Property
-------------------------
relative, absolute, fixed, sticky(sticky cea mai misto.. e ce cautam eu pt nav-bar uri!!)

95. CSS Transitions!
---------------------
prin "transition" property, avem control asupra :
-> property name
-> duration
-> timing function
-> delay


------------------------------------------------------------------------------------
.circle{
    width:300px;
    height:300px;
    background-color: magenta;
    /* transition: 1s; */
    /* transition: background-color 3s; */
    /* transition: background-color 3s 1s; */
    /* 1s, deci al doilea timp e delay-ul! */
    /* transition: all 1s 1s; */
    transition: background-color 3s ease-in, border-radius 2s;
}
/* DEFINITELY SINGLE OUT PROPERTIES TO BE "transitioned" (animated) */

.circle:hover{  /* hover e state-ul.. la schimbare de state se aplica tranzitia de mai sus!!*/
    background-color: cyan;
    border-radius: 50%;
    transition: 0.5s;
}

/* 
Pana aici avem o oarecare tranzitie, dar e din topor. Am putea spune ca vrem ca aceasta tranzitie sa ia 
o secunda intreaga pana sa devina din patrat cerc (si invers)
 */



h1{
    background-color: magenta;
    width: 25%;
    text-align: center;
    padding: 1em;
    color: white;
    transition: background-color 1s ease-in-out, width 1s ease-in-out;
}

h1:hover{
    width: 50%;
    background-color: cyan;
}

section div{
    height: 100px;
    width: 100px;;
    background-color: turquoise;
    margin: 20px 0; 
    transition: margin-left 3s;
}

section:hover div{
    margin-left: 500px;
    /* de regula cica nu facem din astea, ca ar fi o varianta mai buna de a anima chestii */
}
/* asa iau fiecare al n-lea element de acel tip */
div:nth-of-type(1){
    transition-timing-function: ease-in;
    /* ease-in = start slow, then speed up */
}

div:nth-of-type(2){
    transition-timing-function: ease_out;
    /* ease-out = start fast, then slow up */
}

div:nth-of-type(3){
    transition-timing-function: cubic-bezier(0.7,0,0.84,0);
}

div:nth-of-type(4){
    transition-timing-function: cubic-bezier(0.85,0,0.15,1);
}
/* !!Toate ajung la final in acelasi moment de timp  */

/*
REZUMAT
------
Cu "transition" putem specifica 4 chestii:
    - o proprietate pe care vrem sa o animam (gen background-color)
    - o durata de timp pt animatie (secunde sau milisecund)
    - timing function (obs care nu prea are treaba dar totusi pot face asta: pot 
    seta aceeasi animatie pt niste obiecte de un anume tip, iar prin aceasta functie 
    separat pt fiecare vitezele acel "graficul al functiei" deci modul de miscare)
    - delay
*/

-------------------------------------------------------------------------------------

96. The Power of CSS Transforms
------------------------------
transform: scale, translate (dai offset-ui la astea si poate si culori in unele cazuri)


97. Fancy Button Hover Effect
-----------------------------
cum importi font-uri
ceva legat de flexbox

98.

99.


103. FlexBox
------------
un container in care alegem cum distribuim spatiul

cand facem resize se modifica si dimenisunile & layout-ul containerelor

3:30: Deci pricipalul concept pt FlexBox este:
within one container, how do we distribute across differente elements to make those elements
larger OR add space between those elements, move them to the left/right, split up the space
evenly, make sure the first/second...nth thing gets more space

!! WE CREATE FLEXIBE LAYOUTS !!

104. Flex-Direction
-------------------
are cam 8-10 proprietati

"display: flex" --> pt elementul care ma intereseaza
!! ATENTIE: CORECT ESTE "display: flex", NU "display: flexbox"

In Flexbox: 
-----------
atunci cand setam "display:flex" pt un anume container, in acel box container apar 2 axe:
	main axis(orizontala - cred)
	cross axis(verticala - cred)
		(ori variaza in functie de ce precizez eu la "flex-direction")

!!flex-direction seteaza main axis-ul!!

105. Justify-Content
--------------------
!asta depinde de flex-direction!
 
aliniaza elementele across the main axis: la inceput de flex, la sfarsit de flex, centru +
space-between --> doar intre elemente, se neglijeaza border-ul
space-around --> intre elemente, inclusiv border-ul (distanta de la border la primul, respectiv ultimul e jumatate din distanta dintre oricare alte doua items)
space-evenly --> orice distanta intre iteme sau item si border este egala
(check photo)

106.Flex-wrap
------------
Deci flex-direction zice main-axis ul de orientare in container, iar 
flex-wrap zice cross-axis ul de orientare in container !!
(sensul pe directii, adica)

By defalut: "wrap" inseamna stanga-dreapta sau sus-jos; 
"wrap-reverse" inseamna dreapta-stanga sau jos-sus

!!DECI: flex-direction, flex-wrap: seteaza axis-urile!!
!!DECI: justify-content: aliniaza pe main-axis, align-items aliniaza pe cross-axis!!

107. Align items
----------------
-> distribute (space/)our items along the cross-axis (justify-content e along the main-axis)!!!
!!! 

!
optiunea "baseline" (03:18):
 aliniaza dupa pe baza textului (adica dupa "linia imaginara" de dedesubtul textului, a fiecarei litere)
!

!!DECI: flex-direction, flex-wrap: seteaza axis-urile!!
!!DECI: justify-content: aliniaza pe main-axis; align-items: aliniaza pe cross-axis!!

?? 06:39 mai exact, cum se face center-center ala ?? 


108. Align content & align self
-------------------------------
align content -> distribute space along the cross axis (doar cand avem multiple rows/columns),
deci spatiul dintre randuri sau coloane

!DECI EXACT ca justify-content, doar ca pe cross axis

!!DECI: flex-direction, flex-wrap: seteaza axis-urile!!
!!DECI: justify-content: aliniaza pe main-axis, align-items aliniaza pe cross-axis!!

!! align self? similar cu align-items: proprietate pe care o adaugam unor elemente individuale
in the flex container !!

109. Flex-Basis, Grow, & Shrink
-------------------------------
Flex-basis: dimensiunea initiala pe axa principala
Flex-grow: controls the amount of available space an element should take up, if there is available space
Flex-shrink: -analog-

110. Flex shorthand
-------------------
astea de mai sus le putem scrie dintr-un foc: "flex: flex-grow | flex-shrink | flex-basis"

!!check MDN!!

!!DECI: flex-direction, flex-wrap: seteaza axis-urile!!
!!DECI: justify-content: aliniaza pe main-axis, align-items aliniaza pe cross-axis!!
!!SI: align content -> cum le aliniaza along the cross axis DAR INTRE ELE - cumva !!

111. Responsive Design & Media Queries
--------------------------------------
Responsive Design = making a SINGLE website capable of responding to the device that it 
is on (mobile phone / super large monitor / orientation of device)

We accomplish this by using MEDIA QUERIES
MEDIA QUERIES = stilizare bazata pe parametrizare

sintaxa:
@media ...

112. Media Queries
------------------
(Def) = main mechanism that we can use to make a responsive website to restyle/remove/add/
show/hide things... change size/change orientation/go from row to column - schimbari bazate
pe un atribut al browser-ului, fie acesta: width/height/orientation


@media (width: 800px){  
    h1{
        color:blue;
    }
}

"width" se refera la width0ul viewport-ului
Viewport = suprafata poligonala curent vizualizata in browser
deci: - daca sunt in fullscreen mode --> efectiv width-ul ecranului
	- altfel, width-ul a cat este vizibil din pagina curent deschisa in browser

114. Pricing Panel
------------------
CSS Reset --> basic css formating stuff that everybody copies so that they eliminate
bulinele de la list items pt ul, ol, seteaza margini, padding, line-height pt body..
si mai multe; funny ca toata lumea o copiaza :))


120. CSS Frameworks: Bootstrap
------------------------------
Ce este Bootstrap?
Library (third party tool); = css that smn else has written that we can incorporate into our
own code; 

Cum il folosim?
E diferit de ce am folosit noi pana acum. NU SCRIEM NOI CSS !!
Bulma, Foundation, Semantic UI

121. What is Bootstrap?
-----------------------
un framework(un template, pattern)

Ne ajuta sa creem nice-looking responsive websites. Provids the starting point to build a website

What is the Grid System? Its point is to help us layout our websites and have them have pieces
take up space and redistribute that space depending on screen size

122. Including Bootstrap & Containers
----------------------------------------

!! Bootstrap-ul vad ca apare mai mult in HTML, prin clasele tag-urilor!!

CDN = Content Delivery Network; hosted version of a stylesheet that we can access remotely; we do not have
to download it on our machine

<!-- pe getbootstrap.com->Getting Started->Introduction, mai sunt 3 link-uri de inclus daca vrem acces la TOATE componentele Bootstrap -->
<!-- In plus, anumite componente au nevoie de JS. Cele 3 link-uri de care ziceam mai sus, le adaugam right before the closing 'body' tag -->

ASTA E LINK-UL DE INCLUS:
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  

ASTEA SUNT SCRIPT-urile, if I ever need them:
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
        integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
        integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
        integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>

!! EXISTA MULTE CLASE PREDEFINITE IN OUR BOOTSTRAP STYLESHEETS !!

!! Cand facem redimensionarea unei ferestre cu container scris in Bootstrap, obs ca exista niste
breakpoints. Those breakpoints are predefined !!

Container Fluid -> it goes all the way across the screen

123. Bootstrap Buttons
----------------------
??Care e treba cu primary, secondary, success, danger, warning, info, light, dark??
CA LA HTML: 38. Semantic Elements

124. Bootstrap Typograhpy & Utilities
--------------------------------------
display headers

        <blockquote class="blockquote text-right bg-light">
            <!-- this is simlpy a quotation -->
            <!-- "mb-0" margin bottom setata la 0-->
            <p class="mb-0">Lorem ipsum dolor sit amet consectetur adipisicing elit. Pariatur, beatae. Inventore, nobis
                reprehenderit
                id non necessitatibus quae beatae ipsum fuga omnis quis nulla itaque repudiandae nesciunt illo placeat
                praesentium blanditiis?
            </p>
            <footer class="blockquote-footer">Mr. Lorem Ipsum</footer>
        </blockquote>


  <h1 class="display-1 text-center text-primary">Bootstrap Playground</h1>
        <h2 class="display-4">Buttons</h2>
        <!-- 124. -->
        <h1>Placeholder</h1>

        <!-- 123. -->
        <button type="button" class="btn btn-primary">Primary</button>
        <button type="button" class="btn btn-success">Success</button>
        <button type="button" class="btn btn-info">Info</button>
        <button class="btn btn-outline-warning">Warning</button>
        <button class="btn btn-outline-danger">Danger Outline</button>
        <button class="btn btn-outline-info btn-lg">Info Outline</button>
        <button class="btn btn-secondary btn-sm">SM Button</button>
        <button type="button" class="btn btn-success" disabled>Success disabled</button>
        <!-- putem folosi clasele astea si pe anchor tags / input !! -->



125. Badges, Alerts & Button Groups
-----------------------------------
badges...

button-group components..

alerts..

f misto astea

126. Intro to the Bootstrap Grid
--------------------------------
ne ajuta sa creem responsive websites

functioneaza doar:
1) in interiorul unui container
2) daca adaugam un row
<!-- EVERY ROW IN BOOTSTRAP HAS 12 UNITS OF SPACE TO DIVVY UP (A IMPARTI) -->
TRE SA CREEM coloane in randul nostru. Every piece that we want to divvy up is going 
to be a column

127. Responsive Bootstrap Grids
-------------------------------

img-fluid makes an image scale based upon the size of its containing element(containerul care o contine)!!
DECI, DACA PUNEM class="img-fluid¨ inside of an image, atunci imaginea aia isi va schimba dimensiunea daca 
containerul care o contine isi schimba dimensiunea !!

responsive images ?? ceva nu o mers aici !!

gutters

128. Useful Grid Utilities
-------------------------
border, justify, align
justify-content, align-items au variantele de xs, sm, md, lg, xl

129. Bootstrap Forms
--------------------

custom Bootstrap form classes

standard-core concepts: form-group, form-control(-> asta se aplica to most of the
inputs)

<!-- !!!TRY THINKING MOBILE FIRST!!! -->


custom checkboxes, custom radiobuttons

130. Bootstrap Navbars(signature Bootstrap component, except for the grid system)
--------------------------------------------------------------------------------

!!! FOARTE IMPORTANT!!!
responsive

collapsable navbars

cu style setam culoarea!
!!! FOARTE IMPORTANT!!!

131. Bootstrap Icons!
---------------------
svg = scalable vector graphics!!
they "kind of" behave like text!!
fontawesome.com pt mai multe smekere

132. Other Bootstrap Utilities
------------------------------
border (dar nu putem controla width of the border)
class=border-0 boder-primary

shadow

margin&padding (commonly used)

m - margin
p - padding
https://getbootstrap.com/docs/5.0/utilities/spacing/#margin-and-padding

display: block, inline, none
.d-none(tot responsive)

flex-direction(idem)

width: w-25/50/75/100

133. A Mixed Bag of Other Bootstrap Stuff
-----------------------------------------
(cam toate astea includ some javascript)

CARDS
cards - container generic
special header, footer
group

CAROUSEL

DROPDOWNS

SPINNERS

PROGRGESS

! amintim: fluid container go all the way across !


...

138. Museum of Candy Project Part 3
-----------------------------------

139. Museum of Candy Project Part 4
------------------------------------
Bootstrap order-classes we can take advantage of !!
(de revazut astea ca nu le-a explicat bine;
update 1 min mai tarziu :)) : am clarificat, dar tot putea fi oleak mai explicit, ceva gen
" the order refers TO THE DIVs, not the images!! .. poate is eu obosit)

140. Museum of Candy Project Part 4
------------------------------------
DC NU MERGE BACKGROUND ul cu nav bar ul?








141. Javascript Basics
----------------------



142. Why Javascript is awesome
------------------------------
implica logica!, actiuni!!
cart-uri, stock updates... pagina face chestii cu care eu interactionez!!
live-chat, charts, graphs, real complex UIs, nicer animations!!

143. Primitives (primitive types) & The Console
-----------------------------------------------
cum se conecteaza JS to the browser, css, html.. and to the user interaction

tipuri primitive in JS: number, string, boolean, null, undefined
si astea 2: Symbol, BigInt - way less commonly used

unde scriem codul? in consola JS si Chrome

!! in consola --> REPL = read, evaluate, print, loop!!

clear() sau CTRL + L -> curata consola

144. Javascript Numbers
-----------------------
-one number type 

pt decimals exista o limita de eroare tho (15 decimals, more precisely)

!!ATENTIE!!
3.999999999999999(15 DECIMALS)
3.999999999999999

3.9999999999999999(16 DECIMALS)
4

DECI O CHESTIE DE GENUL: 
Math.floor(3.9999999999999999)  // (16 DECIMALS) 
4
POATE FI PROBLEMATICA


2/5 -> ne da un decimal!!

a^b il scriem ca "a**b"

PEMDAS = paranthesis, exponents, multiplication, division, addition, substraction (in ordinea asta)

145. What is NaN
----------------
Not a Number
!! NaN -> considerat un numar, tho. Deci este de tip numar, dar nu reprezinta un numar!!

0/0 		// NaN
1 + NaN 	// NaN
2 * 3		// NaN
DAR: 1/0 	// infinity

operatorul typeof -> are un singur argument; sintaxa: typeof variable/constant

typeof 4 // "number"
typeof 4.1234124 // "number"
!!
typeof NaN 		// "number"
typeof undefined 	//"undefined
!!



146. Quick Numbers Quiz
-----------------------

147. Variables & let
--------------------
(cred ca e weak-tipizat) ca python..
pt ca facem chestii de genul: let year = 1985;
// nu avem nevoie de ";" in consola

"let" cred ca il folosim doar cand declaram o variabila

148. Updating variables
-----------------------

var -> the old way of making variables; orginially, this was the sole method of making variables
nu mai avem de ce sa il folosim acuma.. dar totusi merge

let vs var
----------
Main difference is scoping rules. Variables declared by var keyword are scoped to the 
immediate function body (hence the function scope) while let variables are scoped to the 
immediate enclosing block denoted by { } (hence the block scope).
----------

let variables -> function within
var -> block scope




149. Booleans
-------------
true, false

variables can be changed type !!!

151. Variable Naming and Conventions
------------------------------------

let isLoggedIn

variabilele sunt case-sensitive, pot contine underscore(sau chiar incepe cu underscore), cifre 
DAR nu pot incepe cu cifre! toate numele de variabile sunt camelCased.

current_date -> valid, dar problematic
currentDate -> valid, ok

153. Introducing Strings
------------------------

-> enclosed quotes; single or doubled quotes

154. Indices & Length
----------------------

! Strings are indexed (starting from 0) !
	-> si nu doar ele!!

!!every string has the .length property!!

!!! Strings are immutable !!!!
!! 1 + "merge" // "1merge" ( se face un autoboxing cred; pardon, nu autoboxing de fapt - cred - ci o conversie implicita a operandului
stang in acest caz la string, adica echivalentul sau )

155. String Methods
-------------------
"hello".length 		-> accesam o proprietate
"hello".repeat(4) 	-> executam o metoda

.trim() 		-> mananca whhitespace-ul extra dinainte si de dupa string

156. String Methods with arguments
----------------------------------

!!! .slice(-k) -> de a indexul n + 1 - k pana la inceputul array-ului !!!


!!".indexOf" -> returneaza -1 daca nu gaseste ce trebe!! altfel, indexul la care se gaseste!
returneaza first match only!! (la fel si a arrays!)

msg.slice(a,b) de la pana la b-1 -> inclusiv b-1
.replace(whatToReplace, toBeReplacedWith)		---> doar prima occurence
.replaceAll(whatToReplace, toBefacedWith) 		---> all occurences

157. Template Literals (string-uri parametrizate)
-------------------------------------------------

`I counted ${3+4} sheep` ---> folosim backticks(sub escape, nu single quotes!!) 
si se va evalua ce avem intre ${ ... }

`You bought ${qty} ${product}s. Your total is: ${qty * price} \`(<- this backtick is escaped) `
"You bought 5 Artichokes. Your total is: 11.25 `(<- this backtick is escaped) "


`You bought ${qty} ${product.toUpperCase()}s. Your total is: ${qty * price}`
"You bought 5 ARTICHOKEs. Your total is: 11.25"

158. Null & Undefined
---------------------
"undefined"	-> JS: "i do not know"
"null"		-> intentional lack of value

let logedInUser = null; // asta indica explicit: there is nothing here (AT THE MOMENT)


159. The Math Object
--------------------

Math.abs(-456) // 456

obiect -> collection of properties & methods

Math.floor()
Math.ceil()

chestia de la statistica: vreau in intervalul [a, b] numere, fac: a + rand()*abs(b-a)

160.

161

162. Comparison Operators
-------------------------
??strict equality / strict non-equality??


163. Equality Comparators (including strict (in)equality) adica Triple Vs Double Equals
---------------------------------------------------------------------------------------

DOUBLE EQUALS
-------------
checks for equality of value, but not equality of type!!!
it coerces both values to the same type and then compares them
!! THIS CAN LEAD TO SOME UNEXPECTED RESULTS !!

1 == 1 			//true
1 == '1' 		//true

5 == 5			//true
'b' == 'c' 		//false
7 == '7'		//true
0 == ''			//true
true == false 		//false
0 == false;		//true
!! null == undefined	// true !!

TRIPLE EQUALS (STRICT EQUALITY OPERATOR)
----------------------------------------
--> !!ASTUIA II PASA DE TIP!!!!

1 === 1			//true
1 === '1' 		//false, spre deosebire de ala de mai sus
0 === false		//false, idem

!!! ALWAYS USE TRIPLE (NON-)EQUALS !!! --> IT DOES CARE ABOUT TYPE AND IT IS IMPORTANT TO CARE ABOU TYPE


164. Console, Alert, &Prompt
----------------------------
console
console.log
!! nu prea avem nevoie de console.log("Hello") ca sa afisam "Hello" DAR ATENTIE: asta cand lucram din consola !!
ATENTIE: cand lucram dintr-un fisier - ei bine - acel fisier este complet deconectat de consola. Nu vedem ce scriem in 
acel fisier. Spre deosebire de REPL (read, evaluate, print, loop) cand lucram dintr-un fisier, avem doar RE(read, execute)
partea de print se petrece in browser, I suppose.

!! console este un obiect si el !!

alert("hi there") --> nu face in consola output-ul, ci in browser( in fila asociata din browser )

prompt("mesaj de prompt") --> la fel, dar solicita input de la user (idem)

!! parseInt !!
--------------
let userInput = prompt("please enter a number")
undefined
userInput
"97"
userInput += 1
"971"
userInput -=1
970
parseInt(userInput)
970
let userInput = prompt("please enter a number")
undefined
parseInt(userInput)
97
parseInt("101"
VM1252:1 Uncaught SyntaxError: missing ) after argument list
parseInt("101")
101
parseInt("101asdasdasd")
101
parseInt(userInput) + 1
--------------


165. Running Javascript from a script
-------------------------------------
SHIFT + ENTER: scriem mai multe comenzi in consola; multi-line instructions

+ cum legam .js-file-ul de html

166. If Statements
------------------
...


170. Truthy & Falsey Values
----------------------------

orice valoare in js are o valoare "truthiness/falsiness"; adica corespodentele:
	true sau -respectiv- false

TOATE VALORILE SUNT TRUTHY, EXCEPT:
	-false
	-0
	-""(empty string)
	-NaN
	-undefined

171. Logical AND
----------------
operatii ce ne permit evaluare a large pieces of logic duhh

!! JS este short-circuit evaluation!! daca am: "a OR b", iar a este adevarat, b nu va mai fi
evaluat !!

172. Logical OR
---------------
...
!!!! AND are precedenta mai mare decat OR, adica:
"&&" are precedenta mai mare decat "||" !!!!! (08:28)



173. Logical Not
----------------

(in consola:)null
(in consola:)->null

(in consola):!null
(in consola):->true

??????????????????????????????????????????????????????????????????
CUM AS FACE SA VAD VALOAREA "VALUEY" (TRUTHY) IN ACEST CAZ PT NULL
??????????????????????????????????????????????????????????????????

175. JS Arrays
--------------
typeof array 
--> va indica "object" cu toate ca noi stim ca e array

we can have mixed arrays:
let stuff = [true, 0, 1.23, "miaw", undefined, NaN, null]

176. Array random access
------------------------

!! aparent putem avea empty spaces in an array

let colors = ['rad', 'orange', 'green', 'yellow'];
console.log(colors);

colors[0] = 'red';
console.log(colors);

colors[2] = 'yellow';
console.log(colors);

colors[3] = 'green';
console.log(colors);

console.log(colors[4]);

colors[5] = 'blue';
console.log(colors);

colors[10] = 'blue';
console.log(colors);

177. Push & pop
---------------

push & pop -> add & remove from END of array
!! spre deosebire de strings, aici chiar aducem schimbare obiectului!!
! .push() returneaza lungimea array-ului in urma actualizarii !
! .pop() returneaza ce s-a eliminat din array ! (.pop() pe un array empty va returna undefined)


shift & unshift -> add & remove from START of array
!! spre deosebire de strings, aici chiar aducem schimbare obiectului!!
! .shift() returneaza ce s-a eliminat din array ! (.pop() pe un array empty va returna undefined)
! .unshift() returneaza lungimea array-ului in urma actualizarii !

let movieLine =['tom', 'nancy', 'pablo', 'oliver', 'eva']
movieLine.shift() // returneaza 'tom'

179. Concat, indexOf, includes & reverse
---------------------------------------
!!".indexOf" -> returneaza -1 daca nu gaseste ce trebe!! altfel, indexul la care se gaseste!
returneaza first match only!! (la fel si a arrays!)



180. Slice & splice
--------------------

"?start" -> sugereaza ca parametrul "Start" este optional

array.slice() -> slice din tot array-ul
.slice(k) -> de la indexul k pana la sfaritul array-ului
!!! .slice(-k) -> de a indexul n + 1 - k pana la inceputul array-ului !!!
.slice(a, b) -> de la a la b (fara b!!)


CHECK MDN BEST
--------------
.splice() --> cu asta stergem / inlocuim elemente intr-un array! (returneaza ce a sters din array)
.splice(i,k) --> incepand cu pozitia i, sterge k elemente
/splice(i,0,obiect) --> pe pozitia i insereaza obiect; nu sterge nimic(shifteaza la dreapta)



/*
.splice(k,0) --> insereaza pe pozitia k, impingand-o pe vechea de pe k catre k+1.. (si toate de dupa
cu o pozitie mai la dreapta)
.splice(k,1) --> insereaza pe pozitia k, sterge ce era pe k inainte
.splice(k,m) --> insereaza pe pozitia k, sterge ce era pe [k, k+1, ... k+m-1] inainte
.splice(k,m,DELETED)
*/
--------------
CHECK MDN BEST


182. Arrays + Const !! F IMPORTANT !!
-------------------------------------

!! 
const nums = [1,2,3] !! AICI REFERINTA E CONSTANTA!! NU CONTENT-UL DIN ARRAY!!
DECI POT SCHIMBA ORICE LA ARRAY, NUMAI ADRESA(implicit si tipul) NU !!!
deci nu putem face assignment-uri pe acea variabila; dar putem face operatii pe ea, la
acea adresa!
!!

185. Introducing Object Literals
--------------------------------
- objects = collections of properties
- properties = key-value pair
- in loc sa accesam date folosind un index, vom folosi custom keys


! vad ca un obiect in JS este un dictionar !


186. Creating Object Literals
----------------------------

typeof [] // object.. dar nu le vom numi object

//creem un obiect:
const person = {
	firstName: 'Mick', lastName: 'Jagger'
}

187. Accessing Data Out Of Objects
----------------------------------
!! important !!

const kitchenSink = {
    favNum: 92319023,
    isFunny: true,
    colors: ['red', 'orange']
}
kitchenSink
{favNum: 92319023, isFunny: true, colors: Array(2)}
person["lastName"]
"Jagger"
kitchenSink["asdasdasd"]
undefined
kitchenSink["colors"]
(2) ["red", "orange"]
person
{firstName: "Mick", lastName: "Jagger"}
person.firstName
"Mick"
person."firstName"

const years = {
1999: 'GOOD',
2020: 'BAD'
}
----------------
what happens behind the scenes: EVERY KEY THAT WE MAKE IN AN OBJECT IS CONERTED TO A STRING!!
(EXCEPT FOR SYMBOLS, WHICH WE HAVEN'T TALKED ABOUT YET) --> deci da, cum am zis si eu: sunt string-uri
----------------


diferenta intre person.firstName si person['firstName']
ATENTIE!:
mai sus a mers years[1999] pt ca vedea el ca 1999 e constanta si incerca sa converteasca la int)
aici, in schimb, nu stie ce e cu firstName (fara ghilimele) si nu stie ce sa faca

! deci cu ".numeProprietate" se uita dupa proprietate!!

!! Daca folosim dinamicitate cu cheile (numele unei proprietati intr-o variabila), vom folosi
obj[numeProprietate/numeVariabila] !! Nu putem dinamic cu "."

!! DECI CU [] putem face mai multe!!


188. Modifying Objects
----------------------

nu uitam ca normal nu avem voie asa ceva, danielle fara ghilimele! dar e ok in obiecte!
deci avem voie si asa:
const midterms = {danielle: 96, thomas: 78}
si asa:
const midterms2 = {'danielle': 96, 'thomas': 78}

putem adauga proprietati daca ele inca nu exista deja!!
-----------------------------------------------------------------
midterms
{danielle: 96, thomas: 78}
midterms.thomas = 79
79
midterms
{danielle: 96, thomas: 79}
midterms.thomas = 'C+'
"C+"
midterms['danielle'] = 'A'
"A"
midterms
{danielle: "A", thomas: "C+"}
midterms.ezra
undefined
midterms.ezra = 'B+'
"B+"
midterms
{danielle: "A", thomas: "C+", ezra: "B+"}
midterms['antonio'] = 'A-'
"A-"
midterms
{danielle: "A", thomas: "C+", ezra: "B+", antonio: "A-"}
-----------------------------------------------------------------



189. Nesting Array & Objects
----------------------------

underlying data of Reddit ceva cu JSON


